# 中断机制初始化

## CPU保留的IDT表项以及系统调用的中断初始化

>traps.c-->trap_init()

	void __init trap_init(void)
	{
		#ifdef CONFIG_EISA
		if (isa_readl(0x0FFFD9) == 'E'+('I'<<8)+('S'<<16)+('A'<<24))
			EISA_bus = 1;
		#endif

		/* 首先设置中断向量表的前19个异常 */
		set_trap_gate(0,&divide_error);
		set_trap_gate(1,&debug);
		set_intr_gate(2,&nmi);
		set_system_gate(3,&int3);	/* int3-5 can be called from all */
		set_system_gate(4,&overflow);
		set_system_gate(5,&bounds);
		set_trap_gate(6,&invalid_op);
		set_trap_gate(7,&device_not_available);
		set_trap_gate(8,&double_fault);
		set_trap_gate(9,&coprocessor_segment_overrun);
		set_trap_gate(10,&invalid_TSS);
		set_trap_gate(11,&segment_not_present);
		set_trap_gate(12,&stack_segment);
		set_trap_gate(13,&general_protection);
		set_trap_gate(14,&page_fault); /* 缺页异常 */
		set_trap_gate(15,&spurious_interrupt_bug);
		set_trap_gate(16,&coprocessor_error);
		set_trap_gate(17,&alignment_check);
		set_trap_gate(18,&machine_check);
		set_trap_gate(19,&simd_coprocessor_error);
		
		/*
		 * 创建系统调用的跳转门
		 * #define SYSCALL_VECTOR 0x80
		 * int &0x80指令就是进行一次系统调用
		 */
		set_system_gate(SYSCALL_VECTOR,&system_call);
	
		/*
		 * Linux本身不使用调用门，其他的UNIX变种使用
		 * 此处也进行初始化下操作
		 */
		set_call_gate(&default_ldt[0],lcall7);
		set_call_gate(&default_ldt[4],lcall27);
	
		/*
		 * Should be a barrier for any external CPU state.
		 */
		cpu_init();
	
		#ifdef CONFIG_X86_VISWS_APIC
			superio_init();
			lithium_init();
			cobalt_init();
		#endif
	}
	
**函数中对于各个门的设置，实际上就是对__set_gate()调用的包装**

>traps.c-->__set_gate()

		#define _set_gate(gate_addr,type,dpl,addr) \
		do { \
		  int __d0, __d1; \
		  __asm__ __volatile__ ("movw %%dx,%%ax\n\t" \
			"movw %4,%%dx\n\t" \
			"movl %%eax,%0\n\t" \
			"movl %%edx,%1" \
			:"=m" (*((long *) (gate_addr))), \
			 "=m" (*(1+(long *) (gate_addr))), "=&a" (__d0), "=&d" (__d1) \
			:"i" ((short) (0x8000+(dpl<<13)+(type<<8))), \
			 "3" ((char *) (addr)),"2" (__KERNEL_CS << 16)); \
		} while (0)

* gate_addr: 调用门在中断向量表中的相对位置；、
* type: D标志位和门的类型码；
* dpl： 中断服务的DPL级别；
* addr: 中断服务的跳转函数地址。
***

**怎样包装的呢？**

1.陷阱门： type 15 --> D标志1，类型码111； dpl 0 --> 当前服务的级别是0。

	static void __init set_trap_gate(unsigned int n, void *addr)
	{
		_set_gate(idt_table+n,15,0,addr);
	}

* 说明当前是陷阱门，DPL级别为0，CPU必然可以穿过门进行服务；
* D标志为1，说明xx是32位的；

2.中断门：type 15 --> D标志1，类型码110； dpl 0 --> 当前服务的级别是0。

	void set_intr_gate(unsigned int n, void *addr)
	{
		_set_gate(idt_table+n,14,0,addr);
	}

* 中断门和陷阱门的唯一区别在于是否CPU是否关闭中断以防止嵌套发生。

3.调用门：type 12 --> D标志1， 类型码100； dpl 3 --> 当前服务的级别是3。

	static void __init set_call_gate(void *a, void *addr)
	{
		_set_gate(a,12,3,addr);
	}

4.特殊的系统调用：type 15 --> D标志1，类型码111；dpl 3 -->当前服务的级别是3。

	static void __init set_system_gate(unsigned int n, void *addr)
	{
		_set_gate(idt_table+n,15,3,addr);
	}

*说明系统调用是一种特殊的陷阱门，由于是用户程序带来的陷阱，特权级别3，要让当前调用能穿过此门，需设置dpl为3。
***

## 设置外设通用中断源

*中断控制器8259A初始化*
>i386-->kernel-->i8259.c-->init_IRQ()

	void __init init_IRQ(void)
	{
		int i;
	
	#ifndef CONFIG_X86_VISWS_APIC
		init_ISA_irqs();
	#else
		init_VISWS_APIC_irqs();
	#endif
		/*
		 * 从FIRST_EXTERNAL_VECTOR开始，设置各个中断表项
		 * FIRST_EXTERNAL_VECTOR为0x20，对应的中断号从224开始
		 * 设置的中断服务都来自函数指针数组interrupt[i]
		 */
		for (i = 0; i < NR_IRQS; i++) {
			int vector = FIRST_EXTERNAL_VECTOR + i;
			if (vector != SYSCALL_VECTOR) 
				set_intr_gate(vector, interrupt[i]);
		}
	
	#ifdef CONFIG_SMP
		/*
		 * IRQ0 must be given a fixed assignment and initialized,
		 * because it's used before the IO-APIC is set up.
		 */
		set_intr_gate(FIRST_DEVICE_VECTOR, interrupt[0]);
	
		/*
		 * The reschedule interrupt is a CPU-to-CPU reschedule-helper
		 * IPI, driven by wakeup.
		 */
		set_intr_gate(RESCHEDULE_VECTOR, reschedule_interrupt);
	
		/* IPI for invalidation */
		set_intr_gate(INVALIDATE_TLB_VECTOR, invalidate_interrupt);
	
		/* IPI for generic function call */
		set_intr_gate(CALL_FUNCTION_VECTOR, call_function_interrupt);
	#endif	
	
	#ifdef CONFIG_X86_LOCAL_APIC
		/* self generated IPI for local APIC timer */
		set_intr_gate(LOCAL_TIMER_VECTOR, apic_timer_interrupt);
	
		/* IPI vectors for APIC spurious and error interrupts */
		set_intr_gate(SPURIOUS_APIC_VECTOR, spurious_interrupt);
		set_intr_gate(ERROR_APIC_VECTOR, error_interrupt);
	#endif
	
		/*
		 * Set the clock to HZ Hz, we already have a valid
		 * vector now:
		 */
		outb_p(0x34,0x43);		/* binary, mode 2, LSB/MSB, ch 0 */
		outb_p(LATCH & 0xff , 0x40);	/* LSB */
		outb(LATCH >> 8 , 0x40);	/* MSB */
	
	#ifndef CONFIG_VISWS
		setup_irq(2, &irq2);
	#endif
	
		/*
		 * External FPU? Set up irq13 if so, for
		 * original braindamaged IBM FERR coupling.
		 */
		if (boot_cpu_data.hard_math && !cpu_has_fpu)
			setup_irq(13, &irq13);
	}

***
>i386-->kernel-->i8259.c-->init_IRQ()-->init_ISA_irqs()

	void __init init_ISA_irqs (void)
	{
		int i;
		
		/*
		 * 初始化中断控制器
  		 */
		init_8259A(0);
	
		for (i = 0; i < NR_IRQS; i++) {
			irq_desc[i].status = IRQ_DISABLED;
			irq_desc[i].action = 0;
			irq_desc[i].depth = 1;
	
			if (i < 16) {
				/*
				 * 16 old-style INTA-cycle interrupts:
				 */
				irq_desc[i].handler = &i8259A_irq_type;
			} else {
				/*
				 * 'high' PCI IRQs filled in on demand
				 */
				irq_desc[i].handler = &no_irq_type;
			}
		}
	}

>irq_desc结构数组

	typedef struct {
		unsigned int status;		/* IRQ status */
		hw_irq_controller *handler;
		struct irqaction *action;	/* IRQ action list */
		unsigned int depth;		/* nested irq disables */
		spinlock_t lock;
	} ____cacheline_aligned irq_desc_t;

**结构数组的数组项上限256个**

* 系统本身支持256个中断响应；
* 除却CPU保留的几个位置以外，很难保证位置足够外部中断的使用；
* 所以系统为每个中断向量设置一个队列，根据每个中断的中断向量，将中断服务挂到对应的队列中； 
* 那么当外设中断发生的时候，首先是根据中断向量找到服务队列，然后根据设备号找到对应的子服务。

**处理完子服务入口以后吗，设置每一个IDT的表项**

*通过一个循环设置FIRST_EXTERNAL_VECTOR以后每个表项的值*

*中断函数的跳转地址，来自函数指针数组interrupt[i]*
>i386-->interrupt数组通过含参宏定义

	#define IRQ(x,y) \
		IRQ##x##y##_interrupt
	
	#define IRQLIST_16(x) \
		IRQ(x,0), IRQ(x,1), IRQ(x,2), IRQ(x,3), \
		IRQ(x,4), IRQ(x,5), IRQ(x,6), IRQ(x,7), \
		IRQ(x,8), IRQ(x,9), IRQ(x,a), IRQ(x,b), \
		IRQ(x,c), IRQ(x,d), IRQ(x,e), IRQ(x,f)
	
	void (*interrupt[NR_IRQS])(void) = {
		IRQLIST_16(0x0),
	
	#ifdef CONFIG_X86_IO_APIC
				 IRQLIST_16(0x1), IRQLIST_16(0x2), IRQLIST_16(0x3),
		IRQLIST_16(0x4), IRQLIST_16(0x5), IRQLIST_16(0x6), IRQLIST_16(0x7),
		IRQLIST_16(0x8), IRQLIST_16(0x9), IRQLIST_16(0xa), IRQLIST_16(0xb),
		IRQLIST_16(0xc), IRQLIST_16(0xd)
	#endif
	};


 
