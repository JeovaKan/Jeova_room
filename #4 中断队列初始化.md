# 请求队列初始化

* 中断向量表中，位于0x20前的表项是CPU保留的中断源，如除数为0、缺页等；
* 除了特殊的系统调用 int 0x80位于之后以外，0x20后的表项都用于外设的通用中断源，共有224项；
* 这两者的不同在于，保留的中断表项都是一对一的处理，而后者是通用的，也就是说后者管理了同一类中断服务。

## 外设通用中断队列

>irq.h--> `irq_desc_t`

	typedef struct {
		unsigned int status;		/* IRQ status */
		hw_irq_controller *handler;
		struct irqaction *action;	/* IRQ action list */
		unsigned int depth;		/* nested irq disables */
		spinlock_t lock;
	} ____cacheline_aligned irq_desc_t;
	
	extern irq_desc_t irq_desc [NR_IRQS];

* action域用于维持通用中断源的队列；
* handler指向用于处理中断的类型结构，通常是硬件级用于中断控制器的；

>>`hw_irq_controller`

	struct hw_interrupt_type {
		const char * typename;
		unsigned int (*startup)(unsigned int irq);
		void (*shutdown)(unsigned int irq);
		void (*enable)(unsigned int irq);
		void (*disable)(unsigned int irq);
		void (*ack)(unsigned int irq);
		void (*end)(unsigned int irq);
		void (*set_affinity)(unsigned int irq, unsigned long mask);
	};
	
	typedef struct hw_interrupt_type  hw_irq_controller;

**中断控制器初始化，对于x86来说就是i8259控制器初始化**

>i8259.c-->`init_ISA_irqs`

	void __init init_ISA_irqs (void)
	{
		int i;
	
		init_8259A(0);
	
		for (i = 0; i < NR_IRQS; i++) {
			irq_desc[i].status = IRQ_DISABLED;
			irq_desc[i].action = 0;
			irq_desc[i].depth = 1;
	
			if (i < 16) {
				/*
				 * 16 old-style INTA-cycle interrupts:
				 */
				irq_desc[i].handler = &i8259A_irq_type;
			} else {
				/*
				 * 'high' PCI IRQs filled in on demand
				 */
				irq_desc[i].handler = &no_irq_type;
			}
		}
	}

**前16个保留中断的处理分支被初始化为：**

>>i82559.c-->`i8259A_irq_type`

	static struct hw_interrupt_type i8259A_irq_type = {
		"XT-PIC",
		startup_8259A_irq,
		shutdown_8259A_irq,
		enable_8259A_irq,
		disable_8259A_irq,
		mask_and_ack_8259A,
		end_8259A_irq,
		NULL
	};

**而后面的中断服务暂时被初始化为空**

***
**中断服务的初始化**
>interrupt.h--> irqaction

	struct irqaction {
		void (*handler)(int, void *, struct pt_regs *);
		unsigned long flags;
		unsigned long mask;
		const char *name;
		void *dev_id;
		struct irqaction *next;
	}; 

1. 初始化阶段中断服务实际上并没有真正的服务，只提供空的队列；
2. 需要外设在后续运行中，向系统注册相应的中断服务。

>irq.c --> request_irq

	int request_irq(unsigned int irq, 
			void (*handler)(int, void *, struct pt_regs *),
			unsigned long irqflags, 
			const char * devname,
			void *dev_id)
	{
		int retval;
		struct irqaction * action;
	
	#if 1
		/*
		 * Sanity-check: shared interrupts should REALLY pass in
		 * a real dev-ID, otherwise we'll have trouble later trying
		 * to figure out which interrupt is which (messes up the
		 * interrupt freeing logic etc).
		 */
		if (irqflags & SA_SHIRQ) {
			if (!dev_id)
				printk("Bad boy: %s (at 0x%x) called us without a dev_id!\n", devname, (&irq)[-1]);
		}
	#endif
	
		if (irq >= NR_IRQS)
			return -EINVAL;
		if (!handler)
			return -EINVAL;
	
		action = (struct irqaction *)
				kmalloc(sizeof(struct irqaction), GFP_KERNEL);
		if (!action)
			return -ENOMEM;
	
		action->handler = handler;
		action->flags = irqflags;
		action->mask = 0;
		action->name = devname;
		action->next = NULL;
		action->dev_id = dev_id;
	
		retval = setup_irq(irq, action);
		if (retval)
			kfree(action);
		return retval;
	}

1. unsigned int irq：逻辑上的中断向量号，和IDT表中的物理向量号关联；
2. void (*handler)：中断子服务；
3. unsigned long irqflags：中断属性标志；
4. const char * dev_name：ascii码格式的设备名；
5. void* dev_id：当中断属性是与其他中断共用当前中断时，需要判断的任意一种类型的dev_id是否存在。除此以外，将dev_id数据传递给中断响应的数据结构。

**完成基本的入参检查以及对应数据结构的设置以后，调用setup建立中断服务**
>> irq.c-->request_irq()-->setup_irq()

	int setup_irq(unsigned int irq, struct irqaction * new)
	{
		int shared = 0;
		unsigned long flags;
		struct irqaction *old, **p;
		irq_desc_t *desc = irq_desc + irq;
	
		/*
		 * Some drivers like serial.c use request_irq() heavily,
		 * so we have to be careful not to interfere with a
		 * running system.
		 */
		if (new->flags & SA_SAMPLE_RANDOM) {
			/*
			 * This function might sleep, we want to call it first,
			 * outside of the atomic block.
			 * Yes, this might clear the entropy pool if the wrong
			 * driver is attempted to be loaded, without actually
			 * installing a new handler, but is this really a problem,
			 * only the sysadmin is able to do this.
			 */
			rand_initialize_irq(irq);
		}
	
		/*
		 * The following block of code has to be executed atomically
		 */
		spin_lock_irqsave(&desc->lock,flags);
		p = &desc->action;
		if ((old = *p) != NULL) {
			/* Can't share interrupts unless both agree to */
			if (!(old->flags & new->flags & SA_SHIRQ)) {
				spin_unlock_irqrestore(&desc->lock,flags);
				return -EBUSY;
			}
	
			/* add new interrupt at end of irq queue */
			do {
				p = &old->next;
				old = *p;
			} while (old);
			shared = 1;
		}
	
		*p = new;
	
		if (!shared) {
			desc->depth = 0;
			desc->status &= ~(IRQ_DISABLED | IRQ_AUTODETECT | IRQ_WAITING);
			desc->handler->startup(irq);
		}
		spin_unlock_irqrestore(&desc->lock,flags);
	
		register_irq_proc(irq);
		return 0;
	}

* 如果入参的标志中含有：SA_SAMPLE_RANDOM，那么需要使用熵池，使得当前的中断发生的时间引入一点随机性。
* 随后在队列中移动，判断是否上一个中断和当前中断都具有共享的属性，再把当前中断加入到队列的末端。