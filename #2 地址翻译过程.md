## 反编译hello world

void greeting(void)
{
	printf("Hellow world!");
}

int main(int argc, char* argv[])
{
	greeting();
	return 1;
}

gcc make hello.c

$objdump -d hello 

	/*
	 * 这里是子函数调用的
	 * 反汇编输出结果
	 */
	 call  8048368
	 
	 0x8048368地址是main调用greeting的地址，为虚拟地址。
	 
	 为CPU中的“指令计数器”EIP指向的地址。

 	#define __KERNEL_CS	0x10
	#define __KERNEL_DS	0x18

	#define __USER_CS	0x23
	#define __USER_DS	0x2B
					         index    TI RPL	
	__KERNEL_CS			0000 0000 0001  0|0|00

	__KERNEL_DS			0000 0000 0001  1|0|00

	__USER_CS			0000 0000 0010  0|0|11

	__USER_DS			0000 0000 0010  1|0|11
	
	__KERNEL_CS	index = 2;  TI = 0;  RPL = 0;
	__KERNEL_DS	index = 3;  TI = 0;  RPL = 0;
	__USER_CS       index = 4;  TI = 0;  RPL = 3;
	__USER_DS       index = 5;  TI = 0;  RPL = 3;
	
	Linux内核的设计偏离了Intel本意，因为TI均为0，代表都是从全局GDT的找到页表向。
	实际上Linux内核中基本上不使用局部段描述表LDT。而RPL级只有两个，内核为0级，用户为3级。
	
>head.S-->gdt_table

	ENTRY(gdt_table)
	.quad 0x0000000000000000	/* NULL descriptor */
	.quad 0x0000000000000000	/* not used */
	.quad 0x00cf9a000000ffff	/* 0x10 kernel 4GB code at 0x00000000 */
	.quad 0x00cf92000000ffff	/* 0x18 kernel 4GB data at 0x00000000 */
	.quad 0x00cffa000000ffff	/* 0x23 user   4GB code at 0x00000000 */
	.quad 0x00cff2000000ffff	/* 0x2b user   4GB data at 0x00000000 */
	.quad 0x0000000000000000	/* not used */
	.quad 0x0000000000000000	/* not used */

	K_CS: 0000 0000 1100 1111 1001 1010 0000 0000 0000 0000 0000 0000 1111 1111 1111 1111
	
	K_DS: 0000 0000 1100 1111 1001 0010 0000 0000 0000 0000 0000 0000 1111 1111 1111 1111
	
	K_CS: 0000 0000 1100 1111 1111 1010 0000 0000 0000 0000 0000 0000 1111 1111 1111 1111
	
	K_DS: 0000 0000 1100 1111 1111 0010 0000 0000 0000 0000 0000 0000 1111 1111 1111 1111
	
- B16 ~ B31、B0 ~ B15都是0: 基地址全为0;
- L0 ～ L15、L16 ～ L19都是1: 段上限都是0xffffff;
- C位都是1: 段长度都是4KB；
- D位都是1: 对4个段的访问指令都是32位指令；
- P位都是1： 四个段都在内存中；

**结论：每个段都是从0地址开始的整个4GB虚拟空间，虚拟地址到线性地址的映射保持不变**
**区别在于：**
- 对于KEIRNEL_CS: DPL = 0，表示特权级0，type段1010，表示代码段，可读，可执行，尚未受到访问；
- 对于KEIRNEL_CS: DPL = 0，表示特权级0，type段0010，表示数据段，可读，可写，  尚未受到访问；
- 对于USER_CS:    DPL = 3，表示特权级3，type段1010，表示代码段，可读，可执行，尚未受到访问；
- 对于USER_DS:    DPL = 3，表示特权级3，type段0010，表示数据段，可读，可写，  尚未受到访问；
	
		以32为下标找到gdt表项，并在该值后面添加12个0，以此为地址的指针指向了下一张页面表

		pgd pmd pte 

		按照Intel的规划应该使用3级的表项将虚拟地址转换为物理地址

		实际上linux仅仅使用了pgd和pte来完成。
## 物理内存数据结构的关联
1.每一个物理页面都有一个struct page，系统初始化阶段根据装载的物理内存的大小
建立一个page结构的数组mem_map，每个物理页面的序号就是在数组中的下标

>mem_map内存仓库中物理页面划分为ZONE_NORMAL和ZONE_DMA两个区域

2.每个管理区域都有一组数据结构：struct zone
由于NUMA结构内存的出现，导致管理趋于不再是最大的管理单位
对于每个CPU使用的本地内存节点，包含有两个管理区，再包含有页面

3.代表着存储节点：struct pglist_data


**以上数据结构都用于物理内存的管理**

**物理内存供应，虚拟内存需求，pgd和pte作为桥梁**
