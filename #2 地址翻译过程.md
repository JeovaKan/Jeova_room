## 反编译hello world

void greeting(void)
{
	printf("Hellow world!");
}

int main(int argc, char* argv[])
{
	greeting();
	return 1;
}

gcc make hello.c

$objdump -d hello 

	/*
	 * 这里是子函数调用的
	 * 反汇编输出结果
	 */
	 call  8048368
	 
	 0x8048368地址是main调用greeting的地址，为虚拟地址。
	 
	 为CPU中的“指令计数器”EIP指向的地址。

 	#define __KERNEL_CS	0x10
	#define __KERNEL_DS	0x18

	#define __USER_CS	0x23
	#define __USER_DS	0x2B
					         index   TI RPL	
	__KERNEL_CS			0000 0000 0001 0|0|00

	__KERNEL_DS			0000 0000 0001 1|0|00

	__USER_CS			0000 0000 0010 0|0|11

	__USER_DS			0000 0000 0010 1|0|11

	以32为下标找到gdt表项，并在该值后面添加12个0，以此为地址的指针指向了下一张页面表

	pgd pmd pte 

	按照Intel的规划应该使用3级的表项将虚拟地址转换为物理地址

	实际上linux仅仅使用了pgd和pte来完成。
## 物理内存数据结构的关联
1.每一个物理页面都有一个struct page，系统初始化阶段根据装载的物理内存的大小
建立一个page结构的数组mem_map，每个物理页面的序号就是在数组中的下标

>mem_map内存仓库中物理页面划分为ZONE_NORMAL和ZONE_DMA两个区域

2.每个管理区域都有一组数据结构：struct zone
由于NUMA结构内存的出现，导致管理趋于不再是最大的管理单位
对于每个CPU使用的本地内存节点，包含有两个管理区，再包含有页面

3.代表着存储节点：struct pglist_data


**以上数据结构都用于物理内存的管理**

**物理内存供应，虚拟内存需求，pgd和pte作为桥梁**
